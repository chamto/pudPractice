// ------------------------------------------------------------------------------
//  <autogenerated>
//      20140720 chamto : create
// ------------------------------------------------------------------------------

using System;
using System.Collections;

namespace ML
{


//	public interface IStruct_Init
//	{
//		void Init();
//	}

	public class Util
	{
		static public bool IsZero( float a ) 
		{
			return ( Math.Abs(a) < float.Epsilon );
			
		}
	}


	public partial struct Vector3
	{
//		[Flags]
//		private  enum eAxis : int
//		{
//			X 	= 0,
//			Y 	= 1,
//			Z 	= 2,
//			Max = 3
//		}
//
//		//0:x  , 1:y , 2:z  
//		private float[] axisValue = new float[(int)eAxis.Max];
//
//
//		public float x
//		{
//			get { return axisValue[(int)eAxis.X]; }
//			set { axisValue [(int)eAxis.X] = value; }
//		}
//		public float y
//		{
//			get { return axisValue[(int)eAxis.Y]; }
//			set { axisValue [(int)eAxis.Y] = value; }
//
//		}
//		public float z
//		{
//			get { return axisValue[(int)eAxis.Z]; }
//			set { axisValue [(int)eAxis.Z] = value; }
//		}
//		public float[] array
//		{
//			get { return axisValue; }
//		}


		/// <summary>
		/// Fields
		/// ___________________________________________________________________________
		/// </summary>
		public float x;
		public float y;
		public float z;


		/// <summary>
		/// Indexer
		/// ___________________________________________________________________________
		/// </summary>
		public float this [int index]
		{
			get
			{
				switch (index)
				{
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw new IndexOutOfRangeException ("Invalid Vector3 index!");
				}
			}
			set
			{
				switch (index)
				{
				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				case 2:
					this.z = value;
					break;
				default:
					throw new IndexOutOfRangeException ("Invalid Vector3 index!");
				}
			}
		}


//		public void Zero()
//		{
//			this.x = 0; 
//			this.y = 0;
//			this.z = 0;
//		}
//		public Vector3()
//		{
//			this.x = 0; 
//			this.y = 0;
//			this.z = 0;
//		}
		public Vector3(float _x , float _y , float _z)
		{
			this.x = _x; 
			this.y = _y;
			this.z = _z;
		}

		public float Length()
		{
			//20140818 chamto - [need performance] 표준 제곱근 함수 최적화 필요 , 직접구현 제곱근 함수로 바꾸기
			return (float)System.Math.Sqrt ((double)(this.x * this.x + this.y * this.y + this.z * this.z));
		}

		public float LengthSquared()
		{
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}

		public float Dot(Vector3 other)
		{
			return this.x * other.x + this.y * other.y + this.z * other.z;
		}

		/// <summary>
		/// 외적 : 나 빼고 두곱의 차
		/// </summary>
		/// <param name="other">Other.</param>
		public Vector3 Cross(Vector3 other)
		{
			Vector3 value = new Vector3 ();
			value.x = this.y * other.z - other.y * this.z;
			value.y = this.z * other.x - other.z * this.x;
			value.z = this.x * other.y - other.x * this.y;

			return value;
		}

		public Vector3 Normalize()
		{

			Vector3 value = new Vector3 ();

			float lengthSquared = this.x * this.x + this.y * this.y + this.z * this.z;

			//20140818 chamto - [need performance] 표준 제곱근 함수 최적화 필요 , 직접구현 제곱근 함수로 바꾸기
			float factor = (float)System.Math.Sqrt ((double)lengthSquared);

			//나눗셈 연산을 줄이기 위해 역수로 만듬
			factor = 1.0f / factor; 

			value.x *= factor;
			value.y *= factor;
			value.z *= factor;

			return value;
		}


		/// <summary>
		/// Operators
		/// ___________________________________________________________________________
		/// </summary>
		public static Vector3 operator +(Vector3 c1, Vector3 c2) 
		{
			return new Vector3(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z);
		}

		public static Vector3 operator -(Vector3 c1, Vector3 c2) 
		{
			return new Vector3(c1.x - c2.x, c1.y - c2.y, c1.z - c2.z);
		}

		public static Vector3 operator *(float v1, Vector3 c2) 
		{
			return new Vector3(v1 * c2.x, v1 * c2.y, v1 * c2.z);
		}

		public static Vector3 operator *( Vector3 c2, float v1) 
		{
			return new Vector3(v1 * c2.x, v1 * c2.y, v1 * c2.z);
		}


		/// <summary>
		/// factory method
		/// ___________________________________________________________________________
		/// </summary>
		public static Vector3 Zero 
		{
			get
			{
				return new Vector3(0,0,0);
			}
		}

		public override string ToString ()
		{
			return string.Format ("x: {0}, y: {1}, z: {2}", new object[]
			{
				this.x,
				this.y,
				this.z
			});
		}
	}


	/// <summary>
	/// 직선 , 매개변수가 곱해진 방향값(direction) 을 사용한다
	/// </summary>
	public struct Line3 
	{
		public Vector3 direction;
		public Vector3 origin;

		//두 직선의 교점을 구한다. 두 직선이 평행한 경우, 선과 선사이의 최소거리를 반환한다
		static public void ClosestPoints( out Vector3 point0, out Vector3 point1, 
		                          Line3 line0 , 
		                          Line3 line1 )
		{
			// compute intermediate parameters
			Vector3 w0 = line0.origin - line1.origin;
			float a = line0.direction.Dot( line0.direction );
			float b = line0.direction.Dot( line1.direction );
			float c = line1.direction.Dot( line1.direction );
			float d = line0.direction.Dot( w0 );
			float e = line1.direction.Dot( w0 );
			
			float denom = a*c - b*b;


			if ( ML.Util.IsZero(denom) )
			{
				point0 = line0.origin;
				point1 = line1.origin + (e/c)*line1.direction;
			}
			else
			{
				point0 = line0.origin + ((b*e - c*d)/denom)*line0.direction;
				point1 = line1.origin + ((a*e - b*d)/denom)*line1.direction;
			}
			
		}

	}

	/// <summary>
	/// 반직선 , 매개변수가 곱해진 방향값(direction) 을 사용한다.
	/// </summary>
	public struct Ray3 // : Struct_Init
	{
		public Vector3 direction;
		public Vector3 origin;

	}

	/// <summary>
	/// 선분 , 매개변수가 곱해진 방향값(direction) 을 사용한다.
	/// </summary>
	public struct LineSegment3 //: Struct_Init
	{

		/// <summary>
		/// direction : 선분의 길이* 길이가 1인 방향
		/// origin : 선분의 시작점 
		/// last : 선분의 끝점
		/// </summary>
		/// 
		public Vector3 direction;
		public Vector3 origin;
		public Vector3 last
		{
			get
			{
				return origin + direction;
			}

			set
			{
				direction = value - origin;
			}
		}
		public float last_x
		{
			set
			{
				direction.x = value - origin.x;
			}
		}
		public float last_y
		{
			set
			{
				direction.y = value - origin.y;
			}
		}

		// ---------------------------------------------------------------------------
		// Returns the distance between two endpoints
		//-----------------------------------------------------------------------------
		public float Length()
		{
			return direction.Length();
		}   
		
		

		// ---------------------------------------------------------------------------
		// Returns the squared distance between two endpoints
		//-----------------------------------------------------------------------------
		public float LengthSquared()
		{
			return direction.LengthSquared();
		}


		// ---------------------------------------------------------------------------
		// Returns the closest point on line segment to point
		//-----------------------------------------------------------------------------
		public Vector3 ClosestPoint(Vector3 point )
		{
			Vector3 w = point - origin;
			float proj = w.Dot(direction);
			// endpoint 0 is closest point
			if ( proj <= 0.0f )
				return origin;
			else
			{
				float vsq = direction.Dot(direction);
				// endpoint 1 is closest point
				if ( proj >= vsq )
					return origin + direction;
				// else somewhere else in segment
				else
					return origin + (proj/vsq)*direction;
			}
		}


		// ---------------------------------------------------------------------------
		// Returns the closest points between two line segments.
		//-----------------------------------------------------------------------------
		static public void ClosestPoints(out Vector3 point0,out Vector3 point1, 
		                   LineSegment3 segment0, 
		                   LineSegment3 segment1 )
		{
			// compute intermediate parameters
			Vector3 w0 = segment0.origin - segment1.origin;
			float a = segment0.direction.Dot( segment0.direction );
			float b = segment0.direction.Dot( segment1.direction );
			float c = segment1.direction.Dot( segment1.direction );
			float d = segment0.direction.Dot( w0 );
			float e = segment1.direction.Dot( w0 );
			
			float denom = a*c - b*b;
			// parameters to compute s_c, t_c
			float s_c, t_c;
			float sn, sd, tn, td;
			
			// if denom is zero, try finding closest point on segment1 to origin0
			if ( ML.Util.IsZero(denom) )
			{
				// clamp s_c to 0
				sd = td = c;
				sn = 0.0f;
				tn = e;
			}
			else
			{
				// clamp s_c within [0,1]
				sd = td = denom;
				sn = b*e - c*d;
				tn = a*e - b*d;
				
				// clamp s_c to 0
				if (sn < 0.0f)
				{
					sn = 0.0f;
					tn = e;
					td = c;
				}
				// clamp s_c to 1
				else if (sn > sd)
				{
					sn = sd;
					tn = e + b;
					td = c;
				}
			}
			
			// clamp t_c within [0,1]
			// clamp t_c to 0
			if (tn < 0.0f)
			{
				t_c = 0.0f;
				// clamp s_c to 0
				if ( -d < 0.0f )
				{
					s_c = 0.0f;
				}
				// clamp s_c to 1
				else if ( -d > a )
				{
					s_c = 1.0f;
				}
				else
				{
					s_c = -d/a;
				}
			}
			// clamp t_c to 1
			else if (tn > td)
			{
				t_c = 1.0f;
				// clamp s_c to 0
				if ( (-d+b) < 0.0f )
				{
					s_c = 0.0f;
				}
				// clamp s_c to 1
				else if ( (-d+b) > a )
				{
					s_c = 1.0f;
				}
				else
				{
					s_c = (-d+b)/a;
				}
			}
			else
			{
				t_c = tn/td;
				s_c = sn/sd;
			}
			
			// compute closest points
			point0 = segment0.origin + s_c * segment0.direction;
			point1 = segment1.origin + t_c * segment1.direction;
			
		}


		// ---------------------------------------------------------------------------
		// Returns the minimum distance squared between line segment and point
		// Returns 판별식 t_c = (w⋅v)/(v⋅v)   [0~1 사이의 값] 487p 참고
		//-----------------------------------------------------------------------------
		public float MinimumDistanceSquared(Vector3 point, out float t_c ) 
		{
			Vector3 w = point - origin;
			float proj = w.Dot(direction);
			// endpoint 0 is closest point
			if ( proj <= 0 )
			{
				t_c = 0.0f;
				return w.Dot(w);
			}
			else
			{
				float vsq = direction.Dot(direction);
				// endpoint 1 is closest point
				if ( proj >= vsq )
				{
					t_c = 1.0f;
					return w.Dot(w) - 2.0f*proj + vsq;
				}
				// otherwise somewhere else in segment
				else
				{
					t_c = proj/vsq;
					//CDefine.DebugLog("w.Dot(w) : " + w.Dot(w) + " proj : " + proj + " t_c * proj : " + (t_c * proj) );
					//return w.Dot(w) - t_c * proj;

					//20140911 chamto - bug fix, ref : TestFuncMinDist Scene 
					//실수값 빼기에서 해가 0에 근접할수록 오차값이 생겨 값이 이상해짐
					//테스트를 통해 판별값 0.0001 보다 작은수면 0으로 처리함 , 판별값이 이보다 작아지면 여전히 오차가 발생했음
					//디바이스에서 테스트시 결과가 다를수 있다.
					vsq = w.Dot(w) - t_c * proj;
					if( 0.0001f > vsq) return 0;
					else return vsq;
				}
			}
			
		}  


		// ---------------------------------------------------------------------------
		// Returns the distance squared between two line segments.
		// Based on article and code by Dan Sunday at www.geometryalgorithms.com
		// //선분시작점 + 스칼라값 * 방향 = 두 선분의 가장 가까운 점 : 스칼라값이 s_c, t_c 이다.
		//-----------------------------------------------------------------------------
		static public float DistanceSquared( LineSegment3 segment0, LineSegment3 segment1, out float s_c, out float t_c )
		{
			// compute intermediate parameters
			Vector3 w0 = segment0.origin - segment1.origin;
			float a = segment0.direction.Dot( segment0.direction );
			float b = segment0.direction.Dot( segment1.direction );
			float c = segment1.direction.Dot( segment1.direction );
			float d = segment0.direction.Dot( w0 );
			float e = segment1.direction.Dot( w0 );
			
			float denom = a*c - b*b;
			// parameters to compute s_c, t_c
			float sn, sd, tn, td;
			
			// if denom is zero, try finding closest point on segment1 to origin0
			if ( ML.Util.IsZero(denom) )
			{
				// clamp s_c to 0
				sd = td = c;
				sn = 0.0f;
				tn = e;
			}
			else
			{
				// clamp s_c within [0,1]
				sd = td = denom;
				sn = b*e - c*d;
				tn = a*e - b*d;
				
				// clamp s_c to 0
				if (sn < 0.0f)
				{
					sn = 0.0f;
					tn = e;
					td = c;
				}
				// clamp s_c to 1
				else if (sn > sd)
				{
					sn = sd;
					tn = e + b;
					td = c;
				}
			}
			
			// clamp t_c within [0,1]
			// clamp t_c to 0
			if (tn < 0.0f)
			{
				t_c = 0.0f;
				// clamp s_c to 0
				if ( -d < 0.0f )
				{
					s_c = 0.0f;
				}
				// clamp s_c to 1
				else if ( -d > a )
				{
					s_c = 1.0f;
				}
				else
				{
					s_c = -d/a;
				}
			}
			// clamp t_c to 1
			else if (tn > td)
			{
				t_c = 1.0f;
				// clamp s_c to 0
				if ( (-d+b) < 0.0f )
				{
					s_c = 0.0f;
				}
				// clamp s_c to 1
				else if ( (-d+b) > a )
				{
					s_c = 1.0f;
				}
				else
				{
					s_c = (-d+b)/a;
				}
			}
			else
			{
				t_c = tn/td;
				s_c = sn/sd;
			}
			
			// compute difference vector and distance squared
			Vector3 wc = w0 + s_c*segment0.direction - t_c*segment1.direction;
			return wc.Dot(wc);
			
		}   

		public override string ToString ()
		{
			return string.Format ("origin: {0}, last: {1}, direction: {2}", new object[]
			                      {
				this.origin,
				this.last,
				this.direction
			});
		}


	}//End Class



	/// <summary>
	///    AABB : Axis Aligned Bounding Box
	/// </summary>
	public struct AABBox //: Struct_Init
	{

		public Vector3 mMinima;
		public Vector3 mMaxima;


		//startstartstartstartstartstartstartstartstartstartstartstartstartstartstartstartstart
		#region Sources obsolete - test source 
		private bool _Overlap(Ray3 ray) //20140721 chamto : Stop writing , => func Intersect
		{
			//Formula
			//		Term : parameter => Parameter of Length of Vector

			//		verterR : R(parameter) =  startPt + (dirVtNorm * parameter)
			//		Axis Decomposition : vt = s_pt + d_vt * p
			//			Axis_X : vt_X = s_pt_X + d_vt_X * p
			//			Axis_Y : vt_Y = s_pt_Y + d_vt_Y * p
			//		I do not know the parameter P !!! ->  conversion formula
			//			Axis_X : d_vt_X * p = vt_X - s_pt_X 
			//					 p = (vt_X - s_pt_X) / d_vt_X
			//			Axis_Y : p = (vt_Y - s_pt_Y) / d_vt_Y

			//Slab of AABB 
			//		Term : 
			//		Parameter list : s_x , t_x / s_y , t_y


			//1. init->x , x->y , y->z  Axis Test  



			return true;
		}
		#endregion
		//endendendendendendendendendendendendendendendendendendendendendendendendendendendend



		// ---------------------------------------------------------------------------
		// Determine intersection between AABB and AABB
		//-----------------------------------------------------------------------------
		bool 
		Intersect(AABBox other )
		{
			// if separated in x direction
			if (mMinima.x > other.mMaxima.x || other.mMinima.x > mMaxima.x )
				return false;
			
			// if separated in y direction
			if (mMinima.y > other.mMaxima.y || other.mMinima.y > mMaxima.y )
				return false;
			
			// if separated in z direction
			if (mMinima.z > other.mMaxima.z || other.mMinima.z > mMaxima.z )
				return false;
			
			// no separation, must be intersecting
			return true;
		}

		public bool
		Intersect(Ray3 ray )
		{
			float maxS = float.MinValue;
			float minT = float.MaxValue;
			
			// do tests against three sets of planes
			for ( int i = 0; i < 3; ++i )
			{
				// ray is parallel to plane
				//if ( ::IsZero( ray.GetDirection()[i] ) )
				if( float.Epsilon > Math.Abs (ray.direction[i]))
				{
					// ray passes by box
					if ( ray.origin[i] < mMinima[i] || ray.origin[i] > mMaxima[i] )
						return false;
				}
				else
				{
					// compute intersection parameters and sort
						float s = (mMinima[i] - ray.origin[i])/ray.direction[i];
						float t = (mMaxima[i] - ray.origin[i])/ray.direction[i];
					if ( s > t )
					{
						float temp = s;
						s = t;
						t = temp;
					}
					
					// adjust min and max values
					if ( s > maxS )
						maxS = s;
					if ( t < minT )
						minT = t;
					// check for intersection failure
					if ( minT < 0.0f || maxS > minT )
						return false;
				}
			}
			
			// done, have intersection
			return true;
		}//end method Intersect


		public bool
		Intersect( LineSegment3 segment )
		{
			float maxS = float.MinValue;
			float minT = float.MaxValue;
			
			// do tests against three sets of planes
			for ( int i = 0; i < 3; ++i )
			{
				// segment is parallel to plane
				//if ( ::IsZero( segment.GetDirection()[i] ) )
				if( float.Epsilon > Math.Abs (segment.direction[i]))
				{
					// segment passes by box
					if ( segment.origin[i] < mMinima[i] || segment.origin[i] > mMaxima[i] )
						return false;
				}
				else
				{
					// compute intersection parameters and sort
					float s = (mMinima[i] - segment.origin[i])/segment.direction[i];
					float t = (mMaxima[i] - segment.origin[i])/segment.direction[i];
					if ( s > t )
					{
						float temp = s;
						s = t;
						t = temp;
					}
					
					// adjust min and max values
					if ( s > maxS )
						maxS = s;
					if ( t < minT )
						minT = t;
					// check for intersection failure
					if ( minT < 0.0f || maxS > 1.0f || maxS > minT )
						return false;
				}
			}
			
			// done, have intersection
			return true;
		} 

	}//end class 



}//end namespace

